#!/usr/bin/env python3
"""Compare BP3 MIDI output with SC transpiler output for all available test pairs.

Uses existing MIDI files generated by BP3 and compares with SC transpiler via sclang trace.
"""

import sys
from pathlib import Path
from collections import Counter
from dataclasses import dataclass, field

sys.path.insert(0, '/mnt/d/Claude/BP2SC/src')
sys.path.insert(0, '/mnt/d/Claude/BP2SC/tests')

from bp2sc.grammar.parser import parse_file
from bp2sc.sc_emitter import emit_scd_with_warnings

import mido
from sclang_trace import trace_scd_content, sclang_available

BASE_DIR = Path('/mnt/d/Claude/BP2SC')

# Grammar → MIDI mappings (confirmed pairs)
TEST_PAIRS = [
    {
        'name': 'drum',
        'grammar': BASE_DIR / 'bp3-ctests/-gr.drum',
        'midi': BASE_DIR / 'bp3-ctests/drum.mid',
    },
    {
        'name': 'acceleration',
        'grammar': BASE_DIR / 'bp3-ctests/-gr.acceleration',
        'midi': BASE_DIR / 'bp3-ctests/acceleration.mid',
    },
    {
        'name': 'Visser.Waves',
        'grammar': BASE_DIR / 'bp3-ctests/-gr.Visser.Waves',
        'midi': BASE_DIR / 'bp3-ctests/Visser.Waves1.mid',
    },
    {
        'name': 'Ruwet',
        'grammar': BASE_DIR / 'bp3-ctests/-gr.Ruwet',
        'midi': BASE_DIR / 'tools/ref_ruwet.mid',
    },
    {
        'name': 'produce-all',
        'grammar': BASE_DIR / 'bp3-ctests/produce-all.bpgr',
        'midi': BASE_DIR / 'tools/ref_produce-all.mid',
    },
]


@dataclass
class ComparisonResult:
    name: str

    # BP3 MIDI
    bp3_notes: list = field(default_factory=list)
    bp3_unique: list = field(default_factory=list)
    bp3_durations: dict = field(default_factory=dict)
    bp3_tempo: float = 120.0

    # SC output
    sc_notes: list = field(default_factory=list)
    sc_unique: list = field(default_factory=list)
    sc_durations: dict = field(default_factory=dict)
    sc_warnings: int = 0
    sc_error: str = ""

    # Comparison
    notes_match: bool = False
    only_in_bp3: list = field(default_factory=list)
    only_in_sc: list = field(default_factory=list)


def extract_midi_info(midi_path: Path) -> dict:
    """Extract detailed info from MIDI file."""
    mid = mido.MidiFile(str(midi_path))

    ticks_per_beat = mid.ticks_per_beat
    tempo_us = 500000  # default

    notes = []
    note_ons = []
    note_offs = []

    for track in mid.tracks:
        abs_tick = 0
        for msg in track:
            abs_tick += msg.time
            if msg.type == 'set_tempo':
                tempo_us = msg.tempo
            elif msg.type == 'note_on' and msg.velocity > 0:
                notes.append(msg.note)
                note_ons.append((abs_tick, msg.note))
            elif msg.type == 'note_off' or (msg.type == 'note_on' and msg.velocity == 0):
                note_offs.append((abs_tick, msg.note))

    # Calculate durations
    durations = []
    note_ons_sorted = sorted(note_ons)
    note_offs_sorted = sorted(note_offs)
    used = set()

    for on_tick, on_note in note_ons_sorted:
        for i, (off_tick, off_note) in enumerate(note_offs_sorted):
            if i in used:
                continue
            if off_note == on_note and off_tick >= on_tick:
                dur_ticks = off_tick - on_tick
                dur_beats = dur_ticks / ticks_per_beat
                durations.append(round(dur_beats, 4))
                used.add(i)
                break

    dur_dist = dict(Counter(durations))

    return {
        'notes': notes,
        'unique': sorted(set(notes)),
        'tempo': mido.tempo2bpm(tempo_us),
        'durations': dur_dist,
    }


def trace_sc_output(grammar_path: Path) -> dict:
    """Parse grammar, emit SC, trace output."""
    try:
        ast = parse_file(str(grammar_path))
        sc_content, warnings = emit_scd_with_warnings(ast)

        # Trace with sclang
        events = trace_scd_content(sc_content, start_symbol="S", max_events=500, timeout=60.0)

        notes = []
        durations = []

        for ev in events:
            if ev.type == 'note' and ev.midinote is not None:
                notes.append(int(ev.midinote))

            dur = ev.dur if ev.dur else 0
            stretch = ev.stretch if ev.stretch else 1.0
            eff_dur = dur * stretch
            durations.append(round(eff_dur, 4))

        dur_dist = dict(Counter(durations))

        return {
            'notes': notes,
            'unique': sorted(set(notes)),
            'durations': dur_dist,
            'warnings': len(warnings),
            'error': '',
        }

    except Exception as e:
        return {
            'notes': [],
            'unique': [],
            'durations': {},
            'warnings': 0,
            'error': str(e),
        }


def compare_pair(pair: dict) -> ComparisonResult:
    """Compare one grammar-MIDI pair."""
    result = ComparisonResult(name=pair['name'])

    # Extract BP3 MIDI info
    if pair['midi'].exists():
        bp3_info = extract_midi_info(pair['midi'])
        result.bp3_notes = bp3_info['notes']
        result.bp3_unique = bp3_info['unique']
        result.bp3_durations = bp3_info['durations']
        result.bp3_tempo = bp3_info['tempo']

    # Get SC output
    if pair['grammar'].exists():
        sc_info = trace_sc_output(pair['grammar'])
        result.sc_notes = sc_info['notes']
        result.sc_unique = sc_info['unique']
        result.sc_durations = sc_info['durations']
        result.sc_warnings = sc_info['warnings']
        result.sc_error = sc_info['error']

    # Compare note sets
    if result.bp3_unique and result.sc_unique:
        bp3_set = set(result.bp3_unique)
        sc_set = set(result.sc_unique)
        result.notes_match = bp3_set == sc_set
        result.only_in_bp3 = sorted(bp3_set - sc_set)
        result.only_in_sc = sorted(sc_set - bp3_set)

    return result


def print_detailed_result(r: ComparisonResult):
    """Print detailed comparison for one grammar."""
    print(f"\n{'='*70}")
    print(f"Grammar: {r.name}")
    print(f"{'='*70}")

    print(f"\n--- BP3 MIDI Reference ---")
    print(f"Note count: {len(r.bp3_notes)}")
    print(f"Unique notes: {r.bp3_unique}")
    print(f"Tempo: {r.bp3_tempo:.1f} BPM")
    print(f"Duration distribution (beats): {r.bp3_durations}")

    print(f"\n--- SC Transpiler Output ---")
    if r.sc_error:
        print(f"ERROR: {r.sc_error}")
    else:
        print(f"Note count: {len(r.sc_notes)}")
        print(f"Unique notes: {r.sc_unique}")
        print(f"Duration distribution (beats): {r.sc_durations}")
        print(f"Warnings: {r.sc_warnings}")

    print(f"\n--- Comparison ---")
    if r.notes_match:
        print("✅ Note sets MATCH")
    elif r.sc_error:
        print("⚠️  Could not compare (SC error)")
    else:
        print("❌ Note sets MISMATCH")
        if r.only_in_bp3:
            print(f"   Only in BP3: {r.only_in_bp3}")
        if r.only_in_sc:
            print(f"   Only in SC:  {r.only_in_sc}")

    # Duration comparison
    if r.bp3_durations and r.sc_durations:
        bp3_durs = set(r.bp3_durations.keys())
        sc_durs = set(r.sc_durations.keys())
        if bp3_durs == sc_durs:
            print("✅ Duration vocabulary matches")
        else:
            print("⚠️  Duration vocabulary differs")
            print(f"   BP3: {sorted(bp3_durs)}")
            print(f"   SC:  {sorted(sc_durs)}")


def main():
    print("=" * 70)
    print("BP3 vs SC Transpiler Comparison")
    print("=" * 70)
    print(f"sclang available: {sclang_available()}")
    print(f"Test pairs: {len(TEST_PAIRS)}")

    if not sclang_available():
        print("ERROR: sclang not available!")
        return

    results = []

    for pair in TEST_PAIRS:
        print(f"\nProcessing {pair['name']}...", end=" ", flush=True)
        r = compare_pair(pair)
        results.append(r)

        if r.sc_error:
            print("⚠️  SC error")
        elif r.notes_match:
            print("✅")
        else:
            print("❌")

    # Detailed results
    for r in results:
        print_detailed_result(r)

    # Summary
    print(f"\n{'='*70}")
    print("SUMMARY")
    print(f"{'='*70}")

    total = len(results)
    matches = sum(1 for r in results if r.notes_match)
    errors = sum(1 for r in results if r.sc_error)

    print(f"Total pairs:    {total}")
    print(f"Note matches:   {matches}/{total}")
    print(f"SC errors:      {errors}/{total}")
    print(f"Mismatches:     {total - matches - errors}/{total}")

    # Analysis of mismatches
    print(f"\n--- Mismatch Analysis ---")
    for r in results:
        if not r.notes_match and not r.sc_error:
            print(f"\n{r.name}:")
            if r.only_in_bp3:
                # Analyze what notes are missing
                for note in r.only_in_bp3:
                    name = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][note % 12]
                    octave = note // 12 - 1
                    print(f"  BP3 has {note} ({name}{octave}) - not in SC")
            if r.only_in_sc:
                for note in r.only_in_sc:
                    name = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][note % 12]
                    octave = note // 12 - 1
                    print(f"  SC has {note} ({name}{octave}) - not in BP3")


if __name__ == '__main__':
    main()
